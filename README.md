# WebAssemblyを使ったSpectre攻撃の有効性
ここではポスターに載せきれなかった細かい話を書きます。

## キャッシュタイミング攻撃の実装
キャッシュタイミング攻撃は以下のように実装します。まず、要素が256個（要素のサイズは4096バイトほど）ある配列`array`を用意します。ここで読み取りたいデータ（１バイト）を`x`とし、これを直接読み取ることなく特定します。ここで、一度`array[x]`にアクセスし`array[x]`をキャッシュさせます。このとき`array[x+1]`以降が間違ってキャッシュされないようにサイズを大きくしています。

![](img/cachetiming.png)

その後、`array`の全要素に対してアクセス時間の測定を行います。すると、一要素だけアクセス時間が速くなります。以下の例だと`x=2`の時に高速化しています。よって、最初にアクセスした`array[x]`の`x`の値は`2`であったと特定できる、という仕組みです。

![](img/cachetiming2.png)

## Spectre攻撃の実装
ではSpectreはなんのかというお話をします。


## ブラウザにおけるキャッシュタイミング攻撃の実装
まず前提として、WebAssemblyで使える機能は基本的にAPIとしてランタイムから与えられます。ブラウザでWebAssemblyを動かす場合はJavaScriptエンジン内で実行されるので、WebAssemblyが使える機能は最大でもJavaScriptが使える機能までということになります。なのでWebAssemblyでのキャッシュタイミング攻撃に使えるタイマーは、JavaScriptの`performance.now()`など既存の関数となります。実はSpectreが登場したときにすでにブラウザにおけるSpectre攻撃が問題となり、主要なブラウザでは`performance.now()`などのタイマー系の機能を持つ関数は精度が下げられています。ということで、すでに対策が入っているという現状に対し、本当にそれで大丈夫なのかを確かめるというのが目的となります。

ちなみに精度はchromeで100μs、firefoxで1ms単位の精度となっています。firefoxでは`about:config`から`privacy.reduceTimerPrecision`という項目を`false`にすることで10μs単位の精度に上げることができます。今回は精度を上げたfirefoxで実験しました（これでできなければ安全なので）。

では精度はこれで十分かというと、全然そんなことはありません。CPUのキャッシュミス・ヒットの差はナノ秒単位の差なので、10μs単位のタイマーで測定するにはそれぞれのアクセス時間の差を1000倍程度にする必要があります。そこで、特定対象のデータを